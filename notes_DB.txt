
----------------------------|||   Памятка по СУБД MySQL   |||----------------------------

-- Быстрый старт
	-- Подключение к серверу
-- Язык запросов SQL
 	-- Создаём базу данных
	-- Создание таблиц
	-- Изменение таблицы
	-- Типы данных
-- Работа с данными. CRUD операции
	-- INSERT
	-- SELECT
	-- UPDATE
	-- DELETE
	-- TRUNCATE
-- Операторы.
	-- Арифметические операторы
	-- Операторы сравнения
	-- Логические операторы

-- Условная выборка
	-- BETWEEN
	-- IN
	-- LIKE
	-- RLIKE или REGEXP

-- Сортировка и ограничения
	-- Сортировка
	-- Ограничение выборки
	-- Извлечение уникальных значений
	-- Сортировка и ограничение в DELETE и UPDATE

-- Предопределённые функции Часть 1
	-- Предопределённые функции
	-- Календарные функции
	-- Выборка случайного значения
	-- Справочные функции

---< #Предопределённые функции Часть 2 >---

-- Математические функции
-- Строковые функции
-- Логические функции
-- Вспомогательные функции


--Подключение к серверу

/*Команда соединения MySQL использует следующий синтаксис:

mysql [host] [port] [username] [password] [database]
Каждый из этих аргументов может быть передан команде mysql следующим образом:

--host=host или -hhost
--port=port или -P
--username=username or -uusername
--password=password or -ppassword
база данных задается просто как строка (например db_name) */

mysql -u root -p  --с использованием пользователя и запросом пароля
mysql -u root -h 192.168.0.10 -P 3306 -p  --с данными сервера

mysql -u webgeek -p - подключение к серверу на ноутбуке
login: webgeek 
pass: 09876543
mysql -u root

/*		Чтобы сделать дамп базы данных используется расширение mysqldump. 
		Оно имеет следующий синтаксис: */

mysqldump [username] [password] [database name] > [dump file]

/*		Следующий код логируется в сеанс MySQL с учетной записью пользователя root с 
		паролем secret, затем он выгружает таблицу db_world в файл db_worldbak.sql. */

mysqldump -uroot -psecret db_world > db_worldbak.sql


/*
Внутренние команды клиента MySQL
Команда Сокращение 	Описание
USE 	\u 		Выбор базы данных
SOURCE 	\. 		Выполнение SQL-команды из файла
SYSTEM 	\! 		Выполнение команды операционной системы
STATUS 	\s 		Вывод информации о состоянии сервера
EXIT 	\q 		Выход
	\G 		Вывод результата в вертикальном формате
*/



-------------------------------< Создаём базу данных >-----------------------------------

/* 	Пример базы данных можно скачать на официальном майте MySQL 
	https://dev.mysql.com/doc/index-other.html
 	База emploees. */


-- Создаём базу данных:

CREATE DATABASE test;
CREATE SCHEMA employees; -- или так
CREATE SCHEMA 'shop' DEFAULT CHARACTER SET utf8 COLLATE utf8_bin;-- с указанием кодировки

SHOW DATABASES; -- смотрим существующие базы данных.

DROP DATABASE IF EXISTS test, employees; -- удаляем базы данных.

DROP TABLE IF EXISTS test, test1;  
/*	Удаляем таблицы если существуют(IF EXISTS). Полезно вставлять такуое удаление 
	перед каждым созданием структуры БД, что-бы процесс пересоздания не 
	останавливали ошибки.*/

USE test; --работаем с базой test.

SHOW TABLES; --смотрим какие таблицы существуют в текущей БД.
SHOW TABLES FROM test; -- если конкретная БД не выбрана.



-------------------------------< Создание таблиц >---------------------------------------

-- TAGS:  #CREATE TABLE, #SERIAL, #NOT NULL, #AUTO_INCREMENT, #PRIMARY KEY, #INDEX

DROP TABLE IF EXISTS employees;  
/*		Удаляем таблицы если существуют(IF EXISTS). Полезно вставлять такуое удаление 
		перед каждым созданием структуры БД, что-бы процесс не останавливали ошибки.*/

--  Cоздадим таблицу employees с 6 столбцами:

CREATE TABLE employees (
    emp_no      INT             NOT NULL, -- номер сотрудника типа INT.
    birth_date  DATE            NOT NULL, -- При попытке добавить поле без данных 
    first_name  VARCHAR(14)     NOT NULL, -- в поле с NOT NULL будет ошибка.
    last_name   VARCHAR(16)     NOT NULL, 
    gender      ENUM ('M','F')  NOT NULL,    
    hire_date   DATE            NOT NULL, -- дата найма. Тип данных DATE
    PRIMARY KEY (emp_no),		  -- номер сотрудника назначаем первичным ключём
	
	INDEX index_hire_employees(hire_date) 
		-- для столбца назначается индекс (для быстрого поиска)
		-- можно иcпользовать слово KEY
);

-- Индексы --
CREATE​ ​INDEX​ index_hire_employees ​ ON​ employees (hire_date); 
	-- можно добавить индекс в существующую таблицу

-- Есть 2 типа индексов:
CREATE​ INDEX index_of_catalog_id USING​ BTREE ON products (catalog_id); -- BTREE
CREATE​ INDEX index_of_catalog_id USING HASH​ ON products (catalog_id); -- HASH
-- Бинарное дерево и Хэш индексы.

CREATE TABLE employees (
	id SERIAL PRIMARY KEY -- еще способ назначить столбец первичным ключём
);
	-- SERIAL псевдоним конструкции: BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE

NOT NULL -- ячейка не может быть пустой
AUTO_INCREMENT
/* 	При добавлении данных в столбце автоматически создаётся автоматически увеличивающееся значение. */


SHOW COLUMNS FROM employees; -- смотрим колонки и описанием параметров
DESCRIBE employees ; -- также (только в MySQL)
DESCRIBE employees 'b%'; -- все столбцы начинающиеся с 'b' ('%e' заканчиваются на 'e')
HELP​ ​DESCRIBE​; -- помощь




---|  Изменение таблицы.   |----

-- #ALTER TABLE. Отредактируем состав столбцов таблицы employees:

ALTER TABLE employees 
ADD COLUMN  new_column varchar(128) NOT NULL AFTER last_name;
	-- добавим колоку типа VARCHAR после колонки last_name

ALTER​ TABLE​ employees 
CHANGE​ ​ new_column ​ num_column ​ INT​ ​ UNSIGNED​ ​ NOT​ ​ NULL​ ;
	-- Меняем тип колонки new_column





--------------------------------<  Типы данных  >----------------------------------------

NULL -- нет значения (под него резервируется 65536 байт)


---|  Целые числа  |--- 

BIT(1) -- = 0 или 1 
/*		Тип данных BIT используется для хранения битовых значений. Исполь зуются только 
		нули или единицы. Например, b'111 'и b'10000000' представляют 7 и 128 
		соответственно. */
BIT(10) = 10001000100


INT          = -2 147 883 648 --> 2 147 883 647 (2^31)
INT UNSIGNED =              0 --> 4 294 967 295 (2^32) 
-- UNSIGNED = неподписанный (без информации о знаке)

TINYINT   = 1 байт; -- = –128 … 127, UNSIGNED = 0 … 255
SMALLINT  = 2 байт; -- = –32768 … 32767, unsigned = 0 … 65535
MEDIUMINT = 3 байт;
INT       = 4 байт;
BIGINT    = 8 байт;

CREATE TABLE tbl (id INT(8)); -- 8 - кол-во символов. Выводит пробелы вместо пустых разрядов
CREATE TABLE tbl (id INT(8) ZEROFILL); -- пробелы будут нулями



---|  Вещественные числа  |---

FLOAT = 4 байт; 
DOUBLE = 8 байт;

DECLIMAL = 8 байт -- Число в виде строки
DECIMAL(7,4) --Объявляем число с общим разм. 7 байт, а дробная часть 4 байта. (999.9999)
 


---|  Строковые типы  |---

CHAR    -- Фиксированные
VARCHAR -- Переменный размер. под него резервируется 65536 символов

TINYTEXT   -- 1 байт; 2^8         256
TEXT       -- 2 байт; 2^16      65536(64кб)
MEDIUMTEXT -- 3 байт; 2^24   16777216(16Мб)
LONGTEXT   -- 4 байт; 2^32 4294967295(4Гб)



-- типы TEXT и BLOB ещё медленней VARCHAR

CREATE TABLE tbl (
	name CHAR(10) DEFAULT 'anonimus', -- размер 10 символов, по умолчанию будет 'ano...'
	description VARCHAR(255),
);
INSERT INTO tbl VALUES (DEFAULT, 'Новый пользователь');
-- name = 'anonimus', description = 'Новый пользователь'


-- ENUM --

/*	ENUM - это строковый объект со значением, выбранным из списка разрешенных значений, 
	которые явно перечислены в спецификации столбца во время создания таблицы. */

CREATE TABLE shirts ( -- рубашки
    name VARCHAR(40),
    size ENUM('x-small', 'small', 'medium', 'large', 'x-large'), -- возможные размеры
	composition SET('cotton', 'nylon', 'wool',  'flax') -- возможные материалы
);
/*		 В качестве данных в столбце size хранятся порядковые номера значений, 
		которые перечислены при определении столбца (размеры рубашек) 
		SET, используется так-же, но возможно хранение нескольких вариантов в ячейке.  */


-- JSON --

-- Тип данных в ячейке которого хранится JSON объект (строка).
ALTER​ ​TABLE tbl​ ADD collect JSON​ ;

INSERT​ INTO​ tbl VALUES​ ( 1 ​ , ​ '{"first": "Hello", "second": "World"}'​ );
SELECT​ * ​FROM​ tbl;
SELECT​ collect​ ->> "$.first" FROM​ tbl; -- обращение к JSON элементам
SELECT​ collect ->> "$.second" FROM​ tbl;




---|  Календарные типы данных  |---

TIME      3 байта 00:00:00
DATE      3 байта 0000-00-00
DATETIME  8 байт  0000-00-00 00:00:00
TIMESTAMP 4 байта 0000-00-00 00:00:00 --занимает в два раза меньше места но от 1970 до 2038
YEAR      1 байт  0000

SELECT '2020-13-03 00:00:00';
SELECT '2020-13-03 00:00:00' - INTERVAL 1 DAY ; -- минус 1 день
--YEAR, MONTH, WEEK, DAY, HOUR, MINUTE, SECOND
SELECT '2020-13-03 00:00:00' + INTERVAL '1-1' YEAR_MONTH; -- + год и месяц





-------------------------< Работа с данными. CRUD операции >-----------------------------

-- TAGS:  #INSERT, #SELECT, #UPDATE, #DELETE


INSERT INTO departments VALUES (d007, Sales) 
/*	Вставляем новую строку в таблицу departments с данными в порядке 
	следования столбцов. */


INSERT INTO catalogs VALUES --вставляем три строки
  (DEFAULT, 'Процессоры'), -- неопределённые значения заменяем DEFAULT или NULL
  (NULL, 'Мат.платы'),
  (DEFAULT, 'Видеокарты');
	-- такой многострочный вариант работает быстрее, чем отдельные запросы



SELECT * FROM employees; -- Выведет все столбцы из таблицы employees

SELECT first_name, last_name FROM  employees; -- Выведет 2 соответствующих столбца



DELETE FROM employees; -- удалит данные из таблицы построчно.

TRUNCATE employees; -- обнуляет таблицу, работая быстрее DELETE

DELETE FROM employees LIMIT 2; -- удалит 2 первые записи

DELETE FROM employees WHERE id > 100 LIMIT 1; -- можно со сложным условием


UPDATE departments SET dept_name = 'Market Research' WHERE dept_no = 'd008';
	-- изменили ячейку столбца name в строке с номером подразделения 'd008'

INSERT INTO dep SELECT * FROM departments;
	-- Вставляем в таблицу dep все данные из таблицы departments.
	-- По структуре таблицы должны быть идентичны.


TRUNCATE​ tbl; -- быстрая очистка таблицы


-- #SELECT

SELECT 'Hello world'; -- выведет 'Hello world'  
SELECT​ ​'Rubist\'s world'​ ; -- экранируем кавычку
SELECT​ ​"Rubist's world"​ ; -- либо так '


SELECT 2 ​ + ​ 2; -- 4
SELECT​ ​NULL​ + ​ 2; -- NULL
	-- Все операции с NULL в качестве результата возвращают ​ NULL​ .


SELECT * FROM employees.employees; 
	-- Выведет все столбцы из таблицы employees базы employees 
SELECT * FROM employees;
	-- Если БД уже выбрана командой USE, то указывать её не нужно
SELECT * FROM employees\G 
	-- Выведет не в таблице а по строчно (когда много столбцов)





_________________________________________________________________________________________


 
 
 
_________________________________________________________________________________________

------------------------------------||| Операторы |||------------------------------------


------------------------------<  Арифметические операторы  >-----------------------------

Оператор 	Описание
5 + 2 		Сложение
5 - 2 		Вычитание
2 * 3 		Умножение (главное не выйти за границы размера типа данных)
2 / 3 		Деление
9 % 3 		Остаток от деления
10 DIV 3 	Целочисленное деление

-- примеры:
SELECT​ 3 + 5 AS summ;
UPDATE​ catalogs ​ SET​ ​ id​ = ​ id​ + ​ 10​ ;
SELECT​ '3' + '5'; -- = 8 Приведены к цифрам
SELECT 'abc'+'dfe'; -- = 0 Строка интерпретируется как 0
SELECT -7; -- 
SELECT 8 / 0; -- = NULL Ошибки не вызовет
SELECT 5/2, 5 DIV 2; -- обычное и целочисленное деление
+--------+---------+
| 5/2    | 5 DIV 2 |
+--------+---------+
| 2.5000 |       2 |
+--------+---------+
SELECT 5 % 2, 5 MOD 2 -- = 1, 1 альтернативная запись


                               ---<  Операторы сравнения  >---

SELECT TRUE, FALSE; -- в реальности используется TINYINT
+------+-------+
| TRUE | FALSE |
+------+-------+
|    1 |     0 |
+------+-------+

Оператор 	Описание
> 			Больше
>= 			Больше равно
< 			Меньше
<= 			Меньше равно
= 			Равно
!=, <> 		Не равно
<=> 		Безопасное сравнение (оператор НЛО) позволяет сравнить с NULL

SELECT 2 > 3; -- = 0 ложь

SELECT 2 < 3; -- = 1 истина

SELECT NOT TRUE, NOT FALSE; -- = 0, 1

SELECT ! TRUE, ! FALSE; -- = 0, 1 то же самое

SELECT 2 != 3, 2 <> 3; -- = 1, 1
SELECT NOT 2 != 3, NOT 2 <> 3; -- = 0, 0

SELECT 2 = NULL, 2 != NULL; -- = NULL, NULL;
SELECT 2 <=> NULL, NULL <=> NULL; -- = 0, 1;

SELECT 2 IS NULL, 2 IS NOT NULL, NULL IS NULL, NULL IS NOT NULL; -- = 0, 1, 1, 0



                          ---<  Логические операторы  >---

-- логическое И (AND) -- 
TRUE  AND  TRUE    -- = 1 TRUE 
TRUE  AND  FALSE   -- = 0 FALSE 
TRUE  AND  FALSE   -- = 0 FALSE 
FALSE AND  FALSE   -- = 0 FALSE 

-- логическое ИЛИ (OR) -- 
TRUE  OR  TRUE     -- = 1 TRUE 
TRUE  OR  FALSE    -- = 1 TRUE 
TRUE  OR  FALSE    -- = 1 TRUE 
FALSE OR  FALSE    -- = 0 FALSE 

-- выражения можно сохранять в таблицах:
CREATE TABLE tbl (x INT, y INT, summ INT AS (x + y)); 
	-- складывается значение первого и воторого столбца
INSERT INTO tbl (x, y) VALUES (1,1), (5, 6), (11, 12);
+------+------+------+
| x    | y    | summ |
+------+------+------+
|    1 |    1 |    2 |
|    5 |    6 |   11 |
|   11 |   12 |   23 |
+------+------+------+
-- третий столбец вычисляется при вызове.

--если мы хотим что-бы значения его хранились в базе постоянно (на жёстком диске) то:
CREATE TABLE tbl (x INT, y INT, summ INT AS (x + y) STORED);



-----------------------------|||  Условная выборка  |||----------------------------------



SELECT * FROM catalogs; -- выбрали все столбцы
+----+--------------------+
| id | name               |
+----+--------------------+
|  1 | Процессоры         |
|  2 | Материнские платы  |
|  3 | Видеокарты         |
|  4 | Жесткие диски      |
|  5 | Оперативная память |
+----+--------------------+

SELECT * FROM catalogs WHERE id > 2; -- добавили условия выборки
+----+--------------------+
| id | name               |
+----+--------------------+
|  3 | Видеокарты         |
|  4 | Жесткие диски      |
|  5 | Оперативная память |
+----+--------------------+

mysql> SELECT * FROM catalogs WHERE id > 2 AND id <= 4;
+----+---------------+		-- можно объеденить условия выборки
| id | name          |
+----+---------------+ -- 2 < id <= 4 
|  3 | Видеокарты    |
|  4 | Жесткие диски |
+----+---------------+

-- можно это заменить оператором BETWEEN

SELECT 2 BETWEEN 2 AND 4; -- = 1 TRUE (2 входит в диапазон )
SELECT 20 BETWEEN 2 AND 4; -- = 0 FALSE (20 не входит в диапазон )

SELECT * FROM catalogs WHERE id BETWEEN 3 AND 4; -- id между 3 и 4 включительно
+----+---------------+
| id | name          |
+----+---------------+
|  3 | Видеокарты    |
|  4 | Жесткие диски |
+----+---------------+

SELECT * FROM catalogs WHERE id NOT BETWEEN 3 AND 4;
+----+--------------------+
| id | name               |
+----+--------------------+
|  1 | Процессоры         |
|  2 | Материнские платы  |
|  5 | Оперативная память |
+----+--------------------+

-- оператор #IN

SELECT * FROM catalogs WHERE id IN (1, 2, 5); == всё что входит в список
+----+--------------------+
| id | name               |
+----+--------------------+
|  1 | Процессоры         |
|  2 | Материнские платы  |
|  5 | Оперативная память |
+----+--------------------+

SELECT 2 IN (0, 5, 'str'); -- = 0 FALSE - не входит в список
SELECT 2 IN (0, NULL, 5, 'str'); -- = NULL

SELECT * FROM catalogs WHERE id NOT IN (1, 2, 5);
+----+---------------+		-- NOT IN противоположный IN
| id | name          |
+----+---------------+
|  3 | Видеокарты    |
|  4 | Жесткие диски |
+----+---------------+


--Оператор #LIKE

SELECT * FROM catalogs WHERE name = 'Процессоры';
+----+------------+
| id | name       |
+----+------------+
|  1 | Процессоры |
+----+------------+

SELECT * FROM catalogs WHERE name LIKE 'Процессоры'; -- результат аналогичный
-- разница в том что можно использовать спецсимволы (шаблоны)
-- % - любое кол-во символов   
-- _ - один любой символ

SELECT 'Программист' LIKE 'Программ%'; -- = 1 TRUE 
SELECT 'Программа' LIKE 'Программ%'; -- = 1 TRUE 
SELECT 'Программ' LIKE 'Программ%'; -- = 1 TRUE 
SELECT 'Программирование' LIKE 'П%е'; -- = 1 TRUE 
SELECT 'Программирование' LIKE '%ние'; -- = 1 TRUE 
SELECT 'код' LIKE '___', 'рот' LIKE '___', 'абв' LIKE '___'; -- = 1, 1, 1

SELECT '15%', 'my_sql';
+-----+--------+
| 15% | my_sql |
+-----+--------+
| 15% | my_sql |
+-----+--------+

-- если нужны сами символы, то экранируем:
SELECT '15%' LIKE '15\%', 'my_sql' LIKE 'my\_sql';
+-------------------+-------------------------+
| '15%' LIKE '15\%' | 'my_sql' LIKE 'my\_sql' |
+-------------------+-------------------------+
|                 1 |                       1 |
+-------------------+-------------------------+

--выбираем данные с полем name оканчивающимся на 'ы'
SELECT * FROM catalogs WHERE name LIKE '%ы';
+----+-------------------+
| id | name              |
+----+-------------------+
|  1 | Процессоры        |
|  2 | Материнские платы |
|  3 | Видеокарты        |
+----+-------------------+

SELECT * FROM catalogs WHERE name NOT LIKE '%ы'; -- и наборот
+----+--------------------+
| id | name               |
+----+--------------------+
|  4 | Жесткие диски      |
|  5 | Оперативная память |
+----+--------------------+

--Таблица users
SELECT * FROM users;
+----+-----------+-------------+---------------------+---------------------+
| id | name      | birthday_at | created_at          | updated_at          |
+----+-----------+-------------+---------------------+---------------------+
|  1 | Геннадий  | 1990-10-05  | 2020-03-24 17:11:48 | 2020-03-24 17:11:48 |
|  2 | Наталья   | 1984-11-12  | 2020-03-24 17:11:48 | 2020-03-24 17:11:48 |
|  3 | Александр | 1985-05-20  | 2020-03-24 17:11:48 | 2020-03-24 17:11:48 |
|  4 | Сергей    | 1988-02-14  | 2020-03-24 17:11:48 | 2020-03-24 17:11:48 |
|  5 | Иван      | 1998-01-12  | 2020-03-24 17:11:48 | 2020-03-24 17:11:48 |
|  6 | Мария     | 1992-08-29  | 2020-03-24 17:11:48 | 2020-03-24 17:11:48 |
+----+-----------+-------------+---------------------+---------------------+

-- выберем кто родился в 90-е годы
SELECT * FROM users WHERE birthday_at >= '1990-01-01' AND birthday_at < '2000-01-01';
+----+----------+-------------+---------------------+---------------------+
| id | name     | birthday_at | created_at          | updated_at          |
+----+----------+-------------+---------------------+---------------------+
|  1 | Геннадий | 1990-10-05  | 2020-03-24 17:11:48 | 2020-03-24 17:11:48 |
|  5 | Иван     | 1998-01-12  | 2020-03-24 17:11:48 | 2020-03-24 17:11:48 |
|  6 | Мария    | 1992-08-29  | 2020-03-24 17:11:48 | 2020-03-24 17:11:48 |
+----+----------+-------------+---------------------+---------------------+
-- или:
SELECT * FROM users WHERE birthday_at BETWEEN '1990-01-01' AND '2000-01-01';
-- или:
SELECT * FROM users WHERE birthday_at LIKE '199%';



--Оператор #RLIKE или #REGEXP поиск с регулярными выражениями

SELECT 'грамм' RLIKE 'грам', 'граммпластинка' RLIKE 'грам'\G
		 'грамм' RLIKE 'грам': 1
'граммпластинка' RLIKE 'грам': 1
--ищет включения сразу аналогично LIKE '%грам%'

SELECT 'программирование' RLIKE '^грам', 'грампластинка' RLIKE '^грам'\G
'программирование' RLIKE '^грам': 0
   'грампластинка' RLIKE '^грам': 1
-- ищет в начале слова 

SELECT 'грампластинка' RLIKE '^грампластинка$'; -- ищет всю строку как LIKE

SELECT 'грампластинка' RLIKE 'тинка$';
'грампластинка' RLIKE 'тинка$': 1 -- ищет в конце строки


SELECT 'abc' RLIKE 'abc|абв', 'абв' RLIKE 'abc|абв'\G
'abc' RLIKE 'abc|абв': 1
'абв' RLIKE 'abc|абв': 1

SELECT  'a' RLIKE '[abc]' AS a, -- хотя бы один символ из перечисленных 'abc'
		'b' RLIKE '[abc]' AS b,
		'w' RLIKE '[abc]' AS w; -- переименовать выражение ('a' RLIKE '[abc]') в a
+---+---+---+
| a | b | w |
+---+---+---+ --если есть один из перечисленных символов...
| 1 | 1 | 0 |
+---+---+---+

SELECT 'д' RLIKE '[а-яё]'; -- из диапазона а-я. ё не входит в диапазон, нужно добавить
'д' RLIKE '[а-яё]': 1      -- это особенность русской кодировки -'ё' отдельно от др. сим.

SELECT 7 RLIKE '[0-9]', 7 RLIKE '[0123456789]'; --:1,1  идентичные выражения

-- для подобных диапозонов существуют классы:
SELECT 7 RLIKE '[[:digit:]]'; --:1   хотябы одна цифра
SELECT 'asd' RLIKE '[[:digit:]]'; --:0   

--квантификаторы:
-- ? - символ входит ноль или один раз,
-- * - любое количество вхождений символа включая ноль,
-- + - одно и более вхождений

SELECT '1' RLIKE '^[0-9]+$', --:1 - выражение поиска только числового значения
   '34234' RLIKE '^[0-9]+$', --:1 
  '342.34' RLIKE '^[0-9]+$', --:0
        '' RLIKE '^[0-9]+$'; --:0
		
-- создадим выражение поиска цены
SELECT '342.34' RLIKE '^[0-9]*\\.[0-9]{2}$'; --строка должна соответствовать формату цены
-- [0-9]{2}$ - два цифровых символа в конце строки



---< #Сортировка и ограничения >--- 

--Сортировка
--Ограничение выборки
--Извлечение уникальных значений
--Сортировка и ограничение в DELETE и UPDATE

-- #Сортировка
mysql> SELECT * FROM catalogs order by name; -- сортировка (порядок) по name
+----+--------------------+
| id | name               |
+----+--------------------+
|  3 | Видеокарты         |
|  4 | Жесткие диски      |
|  2 | Материнские платы  |
|  5 | Оперативная память |
|  1 | Процессоры         |
+----+--------------------+

SELECT * FROM catalogs ORDER BY name DESC; -- обратный порядок


SELECT * FROM products;
+---+-------------+---------------+---------+---+-------------------+-------------------+
| id| name        | description   | price   | cat..id | created_at  | updated_at        |
+---+-------------+---------------+---------+---+-------------------+-------------------+ 
| 1 | Int i3-8100 | Проц... INTEL | 7890.00 | 1 |2020-03-24 17:13:33|2020-03-24 17:13:33| 
| 2 | Int i5-7400 | Проц... INTEL |12700.00 | 1 |2020-03-24 17:13:33|2020-03-24 17:13:33|
| 3 | AMD FX-8320E| Проц... AMD.  | 4780.00 | 1 |2020-03-24 17:13:33|2020-03-24 17:13:33| 
| 4 | AMD FX-8320 | Проц... AMD.  | 7120.00 | 1 |2020-03-24 17:13:33|2020-03-24 17:13:33| 
| 5 | ASUS ...    | Мат... ASUS   |19310.00 | 2 |2020-03-24 17:13:33|2020-03-24 17:13:33| 
| 6 | Gigabyte... |Мат... Gigabyte| 4790.00 | 2 |2020-03-24 17:13:33|2020-03-24 17:13:33| 
| 7 | MSI B250M...|Мат... MSI     | 5060.00 | 2 |2020-03-24 17:13:33|2020-03-24 17:13:33| 
+---+-------------+---------------+---------+---+-------------------+-------------------+

SELECT id, catalog_id, price, name FROM products;
+----+------------+----------+-------------------------+
| id | catalog_id | price    | name                    |
+----+------------+----------+-------------------------+
|  1 |          1 |  7890.00 | Intel Core i3-8100      |
|  2 |          1 | 12700.00 | Intel Core i5-7400      |
|  3 |          1 |  4780.00 | AMD FX-8320E            |
|  4 |          1 |  7120.00 | AMD FX-8320             |
|  5 |          2 | 19310.00 | ASUS ROG MAXIMUS X HERO |
|  6 |          2 |  4790.00 | Gigabyte H310M S2H      |
|  7 |          2 |  5060.00 | MSI B250M GAMING PRO    |
+----+------------+----------+-------------------------+

SELECT id, catalog_id, price, name FROM products ORDER BY catalog_id, price;
+----+------------+----------+-------------------------+
| id | catalog_id | price    | name                    |
+----+------------+----------+-------------------------+
|  3 |          1 |  4780.00 | AMD FX-8320E            |
|  4 |          1 |  7120.00 | AMD FX-8320             |
|  1 |          1 |  7890.00 | Intel Core i3-8100      |
|  2 |          1 | 12700.00 | Intel Core i5-7400      |
|  6 |          2 |  4790.00 | Gigabyte H310M S2H      |
|  7 |          2 |  5060.00 | MSI B250M GAMING PRO    |
|  5 |          2 | 19310.00 | ASUS ROG MAXIMUS X HERO |
+----+------------+----------+-------------------------+
--сортировка сначала по catalog_id потом по price.


-- #Ограничение выборки

SELECT id, catalog_id, price, name FROM products LIMIT 2; --выводим только 2 строки
+----+------------+----------+--------------------+
| id | catalog_id | price    | name               |
+----+------------+----------+--------------------+
|  1 |          1 |  7890.00 | Intel Core i3-8100 |
|  2 |          1 | 12700.00 | Intel Core i5-7400 |
+----+------------+----------+--------------------+


SELECT id, catalog_id, price, name FROM products LIMIT 4, 2;
+----+------------+----------+-------------------------+
| id | catalog_id | price    | name                    |
+----+------------+----------+-------------------------+
|  5 |          2 | 19310.00 | ASUS ROG MAXIMUS X HERO |--выводим после 4 позиции
|  6 |          2 |  4790.00 | Gigabyte H310M S2H      |--двухстрочной выборки
+----+------------+----------+-------------------------+
-- альтернативная форма записи:
SELECT id, catalog_id, price, name FROM products LIMIT 2 OFFSET 4;


-- #Извлечение уникальных значений

SELECT DISTINCT catalog_id FROM products ORDER BY catalog_id;
+------------+
| catalog_id |
+------------+
|          1 |  --вывод уникальных значений
|          2 |
+------------+

SELECT ALL catalog_id FROM products ORDER BY catalog_id; 
-- ALL противоположность DISTINCT. Выводит все значения (установлено по умолчанию)


-- Уменьшим цену материнских плат на 10%, но для тех, которые дороже 5000
SELECT id, catalog_id, price, name FROM products WHERE catalog_id = 2 AND price > 5000;
+----+------------+----------+-------------------------+
| id | catalog_id | price    | name                    |
+----+------------+----------+-------------------------+
|  5 |          2 | 19310.00 | ASUS ROG MAXIMUS X HERO |
|  7 |          2 |  5060.00 | MSI B250M GAMING PRO    |
+----+------------+----------+-------------------------+

SELECT id, catalog_id, price, name FROM products;
+----+------------+----------+-------------------------+
| id | catalog_id | price    | name                    |
+----+------------+----------+-------------------------+
|  1 |          1 |  7890.00 | Intel Core i3-8100      |
|  2 |          1 | 12700.00 | Intel Core i5-7400      |
|  3 |          1 |  4780.00 | AMD FX-8320E            |
|  4 |          1 |  7120.00 | AMD FX-8320             |
|  5 |          2 | 17379.00 | ASUS ROG MAXIMUS X HERO |
|  6 |          2 |  4790.00 | Gigabyte H310M S2H      |
|  7 |          2 |  4554.00 | MSI B250M GAMING PRO    |
+----+------------+----------+-------------------------+

-- теперь удалим 2 самые дорогие позиции:
DELETE FROM products ORDER BY price desc LIMIT 2;
+----+------------+---------+----------------------+
| id | catalog_id | price   | name                 |
+----+------------+---------+----------------------+
|  1 |          1 | 7890.00 | Intel Core i3-8100   |
|  3 |          1 | 4780.00 | AMD FX-8320E         |
|  4 |          1 | 7120.00 | AMD FX-8320          |
|  6 |          2 | 4790.00 | Gigabyte H310M S2H   |
|  7 |          2 | 4554.00 | MSI B250M GAMING PRO |
+----+------------+---------+----------------------+
-- отсортировали  по цене в обратном порядке и удалили 2 строки
/* 	Таким образом, всегда можно подобрать подходящие условия при помощи SELECT-запроса, 
	а потом поменять SELECT​ на ​ UPDATE​ или DELETE​. */


----------------------||| Предопределённые функции Часть 1 |||--------------------------

-- Предопределённые функции
-- Календарные функции
-- Выборка случайного значения
-- Справочные функции


-- #Предопределённые функции
SELECT now(); -- Возвращает дату и время текущие
now(): 2020-03-26 12:18:23

describe users; --просмотр структуры таблицы. Наименования и свойства столбцов.
+------------+-------------------+----+---+-----------------+---------------------------+
| Field      |Type               |Null|Key|Default          |Extra                      |
+------------+-------------------+----+---+-----------------+---------------------------+
| id         |bigint(20) unsigned|NO  |PRI|NULL             |auto_increment             |
| name       |varchar(255)       |YES |   |NULL             |                           |
| birthday_at|date               |YES |   |NULL             |                           |
| created_at |datetime           |YES |   |CURRENT_TIMESTAMP|                           |
| updated_at |datetime           |YES |   |CURRENT_TIMESTAMP|on update CURRENT_TIMESTAMP|
+------------+-------------------+----+---+-----------------+---------------------------+

-- столбцы created_at, updated_at задаются неявно. Но мы можем задать их при помощи функции now():
INSERTinto users VALUES (null, 'Александр', '1986-01-20', now(), now());



--------------------------------< Календарные функции >----------------------------------

-- Документация Календарные функции
-- https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_monthname

-- Отображение языка календарных значений. #Язык временных функций
-- https://dev.mysql.com/doc/refman/8.0/en/locale-support.html 

SELECT @@lc_time_names;
+-----------------+
| @@lc_time_names |
+-----------------+
| en_US           |
+-----------------+
 /*Cистемная переменная lc_time_names, управляет языком, используемым для отображения названий и сокращений дней и месяцев. Эта переменная влияет на выходные данные функций DATE_FORMAT (), DAYNAME () и MONTHNAME ().*/
 
 SET @@lc_time_names = 'ru_RU'; -- en_US, en_UK...

SELECT name, created_at, updated_at FROM users WHERE name RLIKE 'Алек';
+-----------+---------------------+---------------------+
| name      | created_at          | updated_at          |
+-----------+---------------------+---------------------+
| Александр | 2020-03-26 12:32:01 | 2020-03-26 12:32:01 |
+-----------+---------------------+---------------------+
-- now() в пределах одного запроса вызывается один раз. По этому время одинаковое

SELECT name, DATE(created_at), DATE(updated_at) FROM users; -- выводим только дату
+-----------+------------------+------------------+
| name      | DATE(created_at) | DATE(updated_at) |
+-----------+------------------+------------------+
| Геннадий  | 2020-03-24       | 2020-03-24       |
| Наталья   | 2020-03-24       | 2020-03-24       |
| Александр | 2020-03-24       | 2020-03-24       |
| Сергей    | 2020-03-24       | 2020-03-24       |
| Иван      | 2020-03-24       | 2020-03-24       |
| Мария     | 2020-03-24       | 2020-03-24       |
+-----------+------------------+------------------+
-- но оперировать конструкцией DATE(created_at) неудобно, часто переименовывают с AS

SELECT id, 
	name, 
	birthday_at, 
	DATE(created_at) AS created_at, 
	DATE(updated_at) AS updated_at 
	FROM users;
	
--также можно AS опускать, заменяя пробелом:
SELECT id, 
	name, 
	birthday_at, 
	DATE(created_at) created_at, 
	DATE(updated_at) updated_at 
	FROM users;
+----+-----------+-------------+------------+------------+
| id | name      | birthday_at | created_at | updated_at |
+----+-----------+-------------+------------+------------+
|  1 | Геннадий  | 1990-10-05  | 2020-03-24 | 2020-03-24 |
|  2 | Наталья   | 1984-11-12  | 2020-03-24 | 2020-03-24 |
|  3 | Александр | 1985-05-20  | 2020-03-24 | 2020-03-24 |
|  4 | Сергей    | 1988-02-14  | 2020-03-24 | 2020-03-24 |
|  5 | Иван      | 1998-01-12  | 2020-03-24 | 2020-03-24 |
|  6 | Мария     | 1992-08-29  | 2020-03-24 | 2020-03-24 |
+----+-----------+-------------+------------+------------+

-- для форматирования даты применяется DATE_FORMAT()
 SELECT DATE_FORMAT( NOW(), 'На дворе %Y год');
+----------------------------------------+
| DATE_FORMAT( NOW(), 'На дворе %Y год') |
+----------------------------------------+
| На дворе 2020 год                      |
+----------------------------------------+ 
/*
%M - Название месяца (январь...декабрь)
%W - Название дня недели (воскресенье...суббота)
%D - День месяца с английским суффиксом (0st, 1st, 2nd, 3rd и т.д.)
%Y	Год, число, 4 разряда
%y	Год, число, 2 разряда
%a	Сокращенное наименование дня недели (Вс...Сб)
%d	День месяца, число (00..31)
%e	День месяца, число (0..31)
%m	Месяц, число (00..12)
%c	Месяц, число (0..12)
%b	Сокращенное наименование месяца (Янв...Дек)
%j	День года (001..366)
%H	Час (00..23)
%k	Час (0..23)
%h	Час (01..12)
%I	Час (01..12)
%l	Час (1..12)
%i	Минуты, число (00..59)
%S	Секунды (00..59)
%s	Секунды (00..59)
-- и т.д. в документации
*/

-- можно отформатировать дату рождения в привычном формате:
SELECT name, DATE_FORMAT(birthday_at, '%d.%m.%Y') AS FROM users;
+-----------+--------------------------------------+
| name      | DATE_FORMAT(birthday_at, '%d.%m.%Y') |
+-----------+--------------------------------------+
| Геннадий  | 05.10.1990                           |
| Наталья   | 12.11.1984                           |
| Александр | 20.05.1985                           |
| Сергей    | 14.02.1988                           |
| Иван      | 12.01.1998                           |
| Мария     | 29.08.1992                           |
+-----------+--------------------------------------+


/* UNIXSTAMP формат.  Преобразование форматов DATETIME <--> UNIXSTAMP

UNIXSTAMP формат времени выраженный в секундах прошедших с 01-01-1970 00:00:00 по  19 января 2038 года в 03:14:08 UTC
Минимальная дата в знаковом 32-битном представлении — 13 декабря 1901 года, 20:45:52 UTC (0x80000000, −2 147 483 648 секунд от 1 января 1970 года).

UNIXSTAMP = 4 байта
DATETIME  = 8 байт

Функции преобразования форматов времени:
DATETIME --> UNIX_TIMESTAMP() --> UNIXSTAMP
UNIXSTAMP --> FROM_UNIXTIME() --> DATETIME

*/
SELECT UNIX_TIMESTAMP('2020-03-26 14:39:12') AS TIMESTAMP\G
TIMESTAMP: 1585215552

SELECT FROM_UNIXTIME('1585215552') AS DATETIME\G
DATETIME: 2020-03-26 14:39:12.000000

SELECT FROM_UNIXTIME('1585215552.8345') AS DATETIME\G
DATETIME: 2020-03-26 14:39:12.834500


--Вычислим возраст пользователей из таблицы users:
SELECT name, FLOOR(TO_DAYS(now()) - TO_DAYS(birthday_at)) / 365.25 AS age FROM users;
+-----------+---------+
| name      | age     |
+-----------+---------+
| Геннадий  | 29.4730 |
| Наталья   | 35.3676 |
| Александр | 34.8501 |
| Сергей    | 32.1123 |
| Иван      | 22.2012 |
| Мария     | 27.5729 |
+-----------+---------+

SELECT name, FLOOR((TO_DAYS(now()) - TO_DAYS(birthday_at)) / 365.25) AS age FROM users;
+-----------+------+
| name      | age  | -- Округлили года
+-----------+------+
| Геннадий  |   29 |
| Наталья   |   35 |
| Александр |   34 |
| Сергей    |   32 |
| Иван      |   22 |
| Мария     |   27 |
+-----------+------+
-- FLOOR округляет в меньшую сторону

-- Также можно воспользоваться другой функцией:
SELECT name, TIMESTAMPDIFF(YEAR, birthday_at, NOW()) AS age FROM users;
+-----------+------+
| name      | age  |
+-----------+------+
| Геннадий  |   29 |
| Наталья   |   35 |
| Александр |   34 |
| Сергей    |   32 |
| Иван      |   22 |
| Мария     |   27 |
+-----------+------+



-- #Выборка случайного значения

-- Можно вывести таблицу в случайном порядке используя функцию RAND()
SELECT name FROM users ORDER BY RAND();
+-----------+
| name      |
+-----------+
| Александр |
| Иван      |
| Сергей    |
| Мария     |
| Геннадий  |
| Наталья   |
+-----------+

-- Выбираем одну случайную запись
mysql> SELECT name FROM users order by RAND() LIMIT 1;
name: Геннадий   

-- #Справочные функции
SELECT VERSION(); --Возвращает текущую версию MySQL сервера.
+------------+
| VERSION()  |
+------------+
| 5.7.25-log |
+------------+

SELECT VERSION() FROM DUAL; -- можно использовать несуществующую псевдотаблицу DUAL
-- Но практически не используется т.к. вывод работает и без неё.

TRUNCATE products;
TRUNCATE catalogs; --очищаем таблицы для следующих примеров
INSERT INTO catalogs VALUES (NULL, 'Процессоры'); -- вставляем название нового каталога
-- SELECT...
+----+------------+ 
| id | name       |
+----+------------+
|  1 | Процессоры |
+----+------------+

-- Узнаем ID последней вставленной строки с автоинкрементом:
SELECT LAST_INSERT_ID() \G --: LAST_INSERT_ID: 1

--Воспользуемся этой функцией для вставки товаров из этого каталога
INSERT INTO products
  (name, description, price, catalog_id)
VALUES
  ('Intel Core i3-8100', 'Процессор Intel.', 7890.00, LAST_INSERT_ID()),
  ('Intel Core i5-7400', 'Процессор Intel.', 12700.00, LAST_INSERT_ID()),
  ('AMD FX-8320E', 'Процессор AMD.', 4780.00, LAST_INSERT_ID()),
  ('AMD FX-8320', 'Процессор AMD.', 7120.00, LAST_INSERT_ID());

--заполнили таблицу с catalog_id равным последней записи в таблицу catalogs  
SELECT id, name, description, price, catalog_id FROM products;
+----+--------------------+------------------+----------+------------+
| id | name               | description      | price    | catalog_id |
+----+--------------------+------------------+----------+------------+
|  1 | Intel Core i3-8100 | Процессор Intel. |  7890.00 |          1 |
|  2 | Intel Core i5-7400 | Процессор Intel. | 12700.00 |          1 |
|  3 | AMD FX-8320E       | Процессор AMD.   |  4780.00 |          1 |
|  4 | AMD FX-8320        | Процессор AMD.   |  7120.00 |          1 |
+----+--------------------+------------------+----------+------------+


--Добавляем материнские карты:
INSERT INTO catalogs VALUES (NULL, 'Материнские платы');
INSERT INTO products
  (name, description, price, catalog_id)
VALUES
  ('ASUS ROG MAXIMUS X HERO', 
  'ASUS ROG MAXIMUS X HERO, Z370,Socket 1151-V2, DDR4, ATX', 19310.00, LAST_INSERT_ID()),
  ('Gigabyte H310M S2H', 
  'Gigabyte H310M S2H, H310, Socket 1151-V2, DDR4, mATX', 4790.00, LAST_INSERT_ID()),
  ('MSI B250M GAMING PRO', 
  'MSI B250M GAMING PRO, B250, Socket 1151, DDR4, mATX', 5060.00, LAST_INSERT_ID());

 SELECT id, name, description, price, catalog_id FROM products;
+----+-------------------------+--------------------------------+----------+------------+
| id | name                    | description                    | price    | catalog_id |
+----+-------------------------+--------------------------------+----------+------------+
|  1 | Intel Core i3-8100      | Процессор Intel.               |  7890.00 |          1 |
|  2 | Intel Core i5-7400      | Процессор Intel.               | 12700.00 |          1 |
|  3 | AMD FX-8320E            | Процессор AMD.                 |  4780.00 |          1 |
|  4 | AMD FX-8320             | Процессор AMD.                 |  7120.00 |          1 |
|  5 | ASUS ROG MAXIMUS X HERO | ASUS ROG MAXIMUS ... DDR4, ATX | 19310.00 |          2 |
|  6 | Gigabyte H310M S2H      | Gigabyte H310M S2H, ...mATX    |  4790.00 |          2 |
|  7 | MSI B250M GAMING PRO    | MSI B250M GAMING PRO...ATX     |  5060.00 |          2 |
+----+-------------------------+--------------------------------+----------+------------+

SELECT * FROM catalogs;
+----+-------------------+
| id | name              |
+----+-------------------+
|  1 | Процессоры        |
|  2 | Материнские платы |
+----+-------------------+ 


SELECT DATABASE(); --: DATABASE(): NULL -- NULL если не выбранна
USE geekbrains;
SELECT DATABASE(); --: DATABASE(): geekbrains - Возвращает текущую базу данных 

SELECT USER(); -- Возвращает текущего кользователя СУБД



----------------------|||  Предопределённые функции Часть 2  |||-------------------------

-- Математические функции
-- Строковые функции
-- Логические функции
-- Вспомогательные функции


-----------------------------<  Математические функции  >--------------------------------

RAND();

-- Вычисление расстояния 
-- Даны координаты двух точек в Декартовой системе координат. x1,y1 x2,y2
-- D = SQRT((x1-x2)^2 + (y1-y2)^2)
--Создадим таблицу:
CREATE TABLE distances (
  id SERIAL PRIMARY KEY,
  x1 INT NOT NULL,
  y1 INT NOT NULL,
  x2 INT NOT NULL,
  y2 INT NOT NULL,
  distance DOUBLE AS (SQRT(POW(x1 - x2, 2) + POW(y1 - y2, 2)))
) COMMENT = 'Расстояние между двумя точками';
-- SQRT- корень квадратный, POW() - возведение в квадрат.

INSERT INTO distances
  (x1, y1, x2, y2)
VALUES
  (1, 1, 4, 5),
  (4, -1, 3, 2),
  (-2, 5, 1, 3);
  
+----+----+----+----+----+--------------------+
| id | x1 | y1 | x2 | y2 | distance           |
+----+----+----+----+----+--------------------+
|  1 |  1 |  1 |  4 |  5 |                  5 |
|  2 |  4 | -1 |  3 |  2 | 3.1622776601683795 |
|  3 | -2 |  5 |  1 |  3 |  3.605551275463989 |
+----+----+----+----+----+--------------------+

-- в качестве альтернативы можно использовать JSON поля
DROP TABLE IF EXISTS distances;
CREATE TABLE distances (
  id SERIAL PRIMARY KEY,
  a JSON NOT NULL,
  b JSON NOT NULL,
  distance DOUBLE AS (SQRT(POW(a->>'$.x' - b->>'$.x', 2) + POW(a->>'$.y' - b->>'$.y', 2)))
) COMMENT = 'Расстояние между двумя точками';
-- a->>'$.x' - оператор двойная стрелка. Использует столбец 'а' с ключём "x". 
-- $ - вершина коллекции

INSERT INTO distances
  (a, b)
VALUES
  ('{"x": 1, "y": 1}', '{"x": 4, "y": 5}'),
  ('{"x": 4, "y": -1}', '{"x": 3, "y": 2}'),
  ('{"x": -2, "y": 5}', '{"x": 1, "y": 3}');

+----+-------------------+------------------+--------------------+
| id | a                 | b                | distance           |
+----+-------------------+------------------+--------------------+
|  1 | {"x": 1, "y": 1}  | {"x": 4, "y": 5} |                  5 |
|  2 | {"x": 4, "y": -1} | {"x": 3, "y": 2} | 3.1622776601683795 |
|  3 | {"x": -2, "y": 5} | {"x": 1, "y": 3} |  3.605551275463989 |
+----+-------------------+------------------+--------------------+



--Вычислим площадь треугольника по его углу и двум сторонам:
-- S = a * b * sin(angle) / 2
CREATE TABLE triangles (
  id SERIAL PRIMARY KEY,
  a DOUBLE NOT NULL COMMENT 'Сторона треугольника',
  b DOUBLE NOT NULL COMMENT 'Сторона треугольника',
  angle INT NOT NULL COMMENT 'Угол треугольника в градусах',
  square DOUBLE AS (a * b * SIN(RADIANS(angle)) / 2.0)
) COMMENT = 'Площадь треугольника';
-- SIN(RADIANS(angle) градусы преобразовываем в радианы, т.к. функция sin() работает с ними.

INSERT INTO
  triangles (a, b, angle)
VALUES
  (1.414, 1, 45),
  (2.707, 2.104, 60),
  (2.088, 2.112, 56),
  (5.014, 2.304, 23),
  (3.482, 4.708, 38);
  
+----+-------+-------+-------+---------------------+
| id | a     | b     | angle | square              |
+----+-------+-------+-------+---------------------+
|  1 | 1.414 |     1 |    45 | 0.49992449429888913 |
|  2 | 2.707 | 2.104 |    60 |  2.4662359679827883 |
|  3 | 2.088 | 2.112 |    56 |  1.8279681567786432 |
|  4 | 5.014 | 2.304 |    23 |   2.256913011738492 |
|  5 | 3.482 | 4.708 |    38 |     5.0463480871756 |
+----+-------+-------+-------+---------------------+
-- результат вычисления имее до 16 знаков после запятой

-- поменяем таблицу для лучшего представления:
ALTER TABLE triangles 
	CHANGE square square DOUBLE AS (ROUND(a * b * SIN(RADIANS(angle)) / 2.0, 4));

SELECT * FROM triangles;
+----+-------+-------+-------+--------+
| id | a     | b     | angle | square |
+----+-------+-------+-------+--------+
|  1 | 1.414 |     1 |    45 | 0.4999 |
|  2 | 2.707 | 2.104 |    60 | 2.4662 |
|  3 | 2.088 | 2.112 |    56 |  1.828 |
|  4 | 5.014 | 2.304 |    23 | 2.2569 |
|  5 | 3.482 | 4.708 |    38 | 5.0463 |
+----+-------+-------+-------+--------+
-- округлили до 4 знака столбец square

-- #округление
ROUND() -- округляет до целого
CELLING() -- округляет в большую сторону
FLOOR() -- округляет в меньшую сторону




---------------------------------<  Строковые функции  >---------------------------------

SELECT id, SUBSTRING(name, 1, 5) AS name FROM users;
+----+-------+
| id | name  |-- извлекает 5 символов с 1 позиции
+----+-------+
|  1 | Генна |
|  2 | Натал |
|  3 | Алекс |
|  4 | Серге |
|  5 | Иван  |
|  6 | Мария |
+----+-------+

--Объединение строк:
SELECT id, CONCAT(name, ' ', TIMESTAMPDIFF(YEAR, birthday_at, NOW())) AS name FROM users;
+----+--------------+
| id | name         |
+----+--------------+
|  1 | Геннадий 29  |
|  2 | Наталья 35   |
|  3 | Александр 34 |
|  4 | Сергей 32    |
|  5 | Иван 22      |
|  6 | Мария 11     |
+----+--------------+
-- к строке с именем, добавили строку с вычисленным возрастом.



---------------------------------<  Логические функции  >--------------------------------


SELECT if(true, 'истина', 'ложь'), if(false, 'истина', 'ложь');
+----------------------------+-----------------------------+
| if(true, 'истина', 'ложь') | if(false, 'истина', 'ложь') |
+----------------------------+-----------------------------+
| истина                     | ложь                        |
+----------------------------+-----------------------------+

-- вычислим совершеннолетие пользователей:
SELECT name, 
	IF(TIMESTAMPDIFF(YEAR, birthday_at, NOW()) >= 18,
		'совершеннолетний',
		'несовершеннолетний'
		)AS status
	FROM users;
+-----------+--------------------+
| name      | status             |
+-----------+--------------------+
| Геннадий  | совершеннолетний   |
| Наталья   | совершеннолетний   |
| Александр | совершеннолетний   |
| Сергей    | совершеннолетний   |
| Иван      | совершеннолетний   |
| Мария     | несовершеннолетний |
+-----------+--------------------+

-- #CASE оператор

-- создадим таблицу с цветами радуги:
DROP TABLE IF EXISTS rainbow;
CREATE TABLE rainbow (
  id SERIAL PRIMARY KEY,
  color VARCHAR(255)
) COMMENT = 'Цвета радуги';

INSERT INTO
  rainbow (color)
VALUES
  ('red'),
  ('orange'),
  ('yellow'),
  ('green'),
  ('blue'),
  ('indigo'),
  ('violet');

SELECT * FROM rainbow;
+----+--------+
| id | color  |
+----+--------+
|  1 | red    |
|  2 | orange |
|  3 | yellow |
|  4 | green  |
|  5 | blue   |
|  6 | indigo |
|  7 | violet |
+----+--------+


-- Если нужно заменить английские названия русскими, можно воспользоваться CASE
SELECT id,
  CASE
    WHEN color = 'red' THEN 'красный'
    WHEN color = 'orange' THEN 'оранжевый'
    WHEN color = 'yellow' THEN 'желтый'
    WHEN color = 'green' THEN 'зеленый'
    WHEN color = 'blue' THEN 'голубой'
    WHEN color = 'indigo' THEN 'синий'
    ELSE 'фиолетовый'
  END AS russian
FROM
  rainbow;

+----+------------+
| id | russian    |
+----+------------+
|  1 | красный    |
|  2 | оранжевый  |
|  3 | желтый     |
|  4 | зеленый    |
|  5 | голубой    |
|  6 | синий      |
|  7 | фиолетовый |
+----+------------+



---------------------------------<  Вспомогательные функции >----------------------------


SELECT INET_ATON('62.145.69.10'), INET_ATON('127.0.0.1');
+---------------------------+------------------------+
| INET_ATON('62.145.69.10') | INET_ATON('127.0.0.1') |
+---------------------------+------------------------+
|                1049707786 |             2130706433 |
+---------------------------+------------------------+
-- принимает IP адрес, и возвращает целое число.


SELECT INET_NTOA('1049707786'), INET_NTOA('2130706433');
+-------------------------+-------------------------+
| INET_NTOA('1049707786') | INET_NTOA('2130706433') |
+-------------------------+-------------------------+
| 62.145.69.10            | 127.0.0.1               |
+-------------------------+-------------------------+
--решает обратную задачу


SELECT UUID();
+--------------------------------------+
| UUID()                               |
+--------------------------------------+
| 4321bc7e-6f82-11ea-86d3-50e54931ce2d | --: b4d19800-6f82-11ea-86d3-50e54931ce2d
+--------------------------------------+
-- Возвращает универсальный уникальный идентификатор (UUID) будет всегда разным.

SELECT UUID_SHORT(); --: 98652920005787648




_________________________________________________________________________________________

----------------------------|||  Агрегация данных  |||-----------------------------------

--- Группировка данных
--- Агрегационные функции
--- Специальные возможности GROUP BY


-----------------------------<  Группировка данных  >------------------------------------

SELECT catalog_id FROM products GROUP BY catalog_id;
+------------+
| catalog_id |
+------------+
|          1 |
|          2 |
+------------+

-- разобьём пользователей на группы родившихся в разные десятилетия:
SELECT id, name, SUBSTRING(birthday_at, 1, 3) AS decade FROM users;
+----+-----------+--------+
| id | name      | decade |
+----+-----------+--------+
|  1 | Геннадий  | 199    | -- отбросим единицы годов
|  2 | Наталья   | 198    |
|  3 | Александр | 198    |
|  4 | Сергей    | 198    |
|  5 | Иван      | 199    |
|  6 | Мария     | 200    |
+----+-----------+--------+

SELECT id, name, SUBSTRING(birthday_at, 1, 3) AS decade FROM users order by decade;
+----+-----------+--------+
| id | name      | decade |
+----+-----------+--------+
|  2 | Наталья   | 198    | -- отсортируем по декадам
|  3 | Александр | 198    |
|  4 | Сергей    | 198    |
|  1 | Геннадий  | 199    |
|  5 | Иван      | 199    |
|  6 | Мария     | 200    |
+----+-----------+--------+

SELECT SUBSTRING(birthday_at, 1, 3) AS decade FROM users GROUP BY decade;  
+--------+
| decade |
+--------+
| 198    |
| 199    |
| 200    |
+--------+                                                                       
-- при этом другие столбцы не выведет


SELECT COUNT(*) total, SUBSTRING(birthday_at, 1, 3) AS decade FROM users GROUP BY decade order by total;
+-------+--------+
| total | decade |
+-------+--------+
|     1 | 200    | --  COUNT(*) считает количество сгруппированных элементов
|     2 | 199    |
|     3 | 198    |
+-------+--------+
-- отсортировали по значениям количества эл-тов в группах
-- причём нельзя располагать ORDER BY раньше GROUP BY. 

SELECT COUNT(*) FROM users; -- можно применить ко всем элементам таблицы
+----------+
| COUNT(*) |
+----------+
|        6 |
+----------+

-- посмотреть содержимое групп можно так:
SELECT GROUP_CONCAT(name), SUBSTRING(birthday_at, 1, 3) AS decade FROM users GROUP BY decade;
+--------------------------+--------+
| GROUP_CONCAT(name)       | decade |
+--------------------------+--------+
| Наталья,Александр,Сергей | 198    |-- конкотенирует строки одной группы
| Геннадий,Иван            | 199    |
| Мария                    | 200    |
+--------------------------+--------+
-- GROUP_CONCAT() - Эта функция возвращает строковый результат с объединенными ненулевыми значениями из группы. Возвращает NULL, если нет ненулевых значений.

SELECT GROUP_CONCAT(name SEPARATOR '; '), SUBSTRING(birthday_at, 1, 3) AS decade FROM users GROUP BY decade;
+-----------------------------------+--------+
| GROUP_CONCAT(name SEPARATOR '; ') | decade |
+-----------------------------------+--------+
| Наталья; Александр; Сергей        | 198    | -- можно менять разделитель
| Геннадий; Иван                    | 199    |
| Мария                             | 200    |
+-----------------------------------+--------+

SELECT GROUP_CONCAT(name order by name DESC SEPARATOR '; '), SUBSTRING(birthday_at, 1, 3) AS decade FROM users GROUP BY decade;
+------------------------------------------------------+--------+
| GROUP_CONCAT(name order by name DESC SEPARATOR '; ') | decade |
+------------------------------------------------------+--------+
| Сергей; Наталья; Александр                           | 198    |--можно ещё и сортировать
| Иван; Геннадий                                       | 199    |
| Мария                                                | 200    |
+------------------------------------------------------+--------+

-- GROUP_CONCAT() может извлечь максимум 1000 эл-тов если не поменять настройки сервера


-------------------------------<  Агрегационные функции  >-------------------------------

--#COUNT()
COUNT() -- является агрегационной, т.к. меняет своё значение при использовании в GROUP BY

SELECT COUNT(id) FROM catalogs;

+-----------+
| COUNT(id) |
+-----------+ 
|         5 |-- возвращает количество эл-тов таблицы отличных от NULL
+-----------+
-- При использовании COUNT(*) вернёт количество строк (даже null)

-- есть таблица:
mysql> SELECT * FROM tbl;
+----+-------+
| id | VALUE |
+----+-------+
|  1 |   230 |
|  2 |  NULL |
|  3 |   405 |
|  4 |  NULL |
+----+-------+

--применим COUNT() к обоим столбцам
mysql> SELECT COUNT(id), COUNT(VALUE) FROM tbl;
+-----------+--------------+
| COUNT(id) | COUNT(VALUE) |
+-----------+--------------+
|         4 |            2 |-- значения отличаются, т.к. COUNT() игнорирует NULL поля
+-----------+--------------+

SELECT COUNT(*) FROM tbl;
+----------+
| COUNT(*) |
+----------+
|        4 | -- значения NULL не влияют на результат
+----------+


--подсчитаем количество элементов в таблице products
SELECT
	COUNT(id) AS total_ids, 
	COUNT(catalog_id) AS total_catalog_ids 
FROM 
	products;
+-----------+-------------------+
| total_ids | total_catalog_ids |
+-----------+-------------------+
|         7 |                 7 |
+-----------+-------------------+

--лднако если добавим DISTINCT:
SELECT
	COUNT(DISTINCT id) AS total_ids, 
	COUNT(DISTINCT catalog_id) AS total_catalog_ids 
FROM 
	products;
+-----------+-------------------+
| total_ids | total_catalog_ids |
+-----------+-------------------+
|         7 |                 2 | -- подсчитались только уникальные значения
+-----------+-------------------+

-- #MIN #MAX - извлекают минимальные и максимальные значения
SELECT
	MIN(price) AS MIN,
	MAX(price) AS MAX 
FROM 
	products;
+---------+----------+
| MIN     | MAX      |
+---------+----------+
| 4780.00 | 19310.00 | -- получаем минимальную и максимальную цену столбца
+---------+----------+

/* при группировке по полю catalog_id можем получать миниматьную и максимальную цену 
каждого из разделов каталога*/
SELECT
	catalog_id,
	MIN(price) AS MIN,
	MAX(price) AS MAX 
FROM 
	products
GROUP BY
	catalog_id;
+------------+---------+----------+
| catalog_id | MIN     | MAX      |
+------------+---------+----------+
|          1 | 4780.00 | 12700.00 |
|          2 | 4790.00 | 19310.00 |
+------------+---------+----------+
/* агрегационные функции применяются только после слова SELECT
нельзя выполнить SELECT * FROM products WHERE price = MAX(price); лучше использовать:
SELECT id, name, price FROM products order by price DESC LIMIT 1; если мы хотим найти максимальную цену */


-- #AVG - среднее значение

SELECT AVG(price) FROM products;
+-------------+
| AVG(price)  |
+-------------+
| 8807.142857 |
+-------------+

SELECT ROUND(AVG(price), 2) FROM products; 
+-------------------+
| ROUND(AVG(price)) |
+-------------------+
|           8807.14 | -- округлили
+-------------------+

SELECT 
	catalog_id, 
	ROUND(AVG(price), 2) AS price 
FROM products 
GROUP BY catalog_id;
+------------+---------+
| catalog_id | price   |
+------------+---------+
|          1 | 8122.50 |
|          2 | 9720.00 |
+------------+---------+

-- внутри функции допускается вычислять значения
SELECT 
	catalog_id, 
	ROUND(AVG(price * 1.2), 2) AS price 
FROM products 
GROUP BY catalog_id;
+------------+----------+
| catalog_id | price    |
+------------+----------+
|          1 |  9747.00 |
|          2 | 11664.00 |
+------------+----------+

-- #SUM - сумма значений всего столбца
SELECT SUM(price) FROM products;
+------------+
| SUM(price) |
+------------+
|   61650.00 |
+------------+

SELECT catalog_id, SUM(price) FROM products GROUP BY catalog_id;
+------------+------------+
| catalog_id | SUM(price) |
+------------+------------+
|          1 |   32490.00 | -- сумма в каждой категории
|          2 |   29160.00 |
+------------+------------+

-- #Специальные возможности GROUP BY
SELECT 
	GROUP_CONCAT(name), 
	SUBSTRING(birthday_at, 1, 3) AS decade 
FROM users 
GROUP BY decade;
+-----------------------------------+--------+
| GROUP_CONCAT(name SEPARATOR '; ') | decade |
+-----------------------------------+--------+
| Наталья; Александр; Сергей        | 198    | -- можно менять разделитель
| Геннадий; Иван                    | 199    |
| Мария                             | 200    |
+-----------------------------------+--------+

SELECT 
	COUNT(*) AS total, 
	SUBSTRING(birthday_at, 1, 3) AS decade 
FROM users 
GROUP BY decade;
+-------+--------+
| total | decade |
+-------+--------+
|     3 | 198    |
|     2 | 199    |
|     1 | 200    |
+-------+--------+
 
/*если нам нужно выбрать группы где, например, более 2-х записей, то использование WHERE 
 приведёт к ошибке. Для решения этой проблемы используется слово:
 
 #HEAVING
 */
SELECT 
	COUNT(*) AS total, 
	SUBSTRING(birthday_at, 1, 3) AS decade 
FROM 
	users 
GROUP BY 
	decade
HAVING 
	total>= 2;
+-------+--------+
| total | decade |
+-------+--------+
|     3 | 198    |
|     2 | 199    |
+-------+--------+

-- допускается использование HAVING без использования GROUP BY
SELECT 
	*
FROM 
	users 
HAVING 
	birthday_at >= '1990-01-01';
+----+----------+-------------+---------------------+---------------------+
| id | name     | birthday_at | created_at          | updated_at          |
+----+----------+-------------+---------------------+---------------------+
|  1 | Геннадий | 1990-10-05  | 2020-03-24 17:11:48 | 2020-03-24 17:11:48 |
|  5 | Иван     | 1998-01-12  | 2020-03-24 17:11:48 | 2020-03-24 17:11:48 |
|  6 | Мария    | 2006-08-29  | 2020-03-24 17:11:48 | 2020-03-27 11:18:58 |
+----+----------+-------------+---------------------+---------------------+
--вывели пользователей родившиеся после 90-го года
-- в этом случае каждая строка таблицы рассматривается как группа



-- добавим идентичные записи в таблицу products
+----+-------------------------+---------------------------------------------------------+
| id | name                    | description                                             |
+----+-------------------------+---------------------------------------------------------+
|  1 | Intel Core i3-8100      | Процессор Intel.                                        |
|  2 | Intel Core i5-7400      | Процессор Intel.                                        |
|  3 | AMD FX-8320E            | Процессор AMD.                                          |
|  4 | AMD FX-8320             | Процессор AMD.                                          |
|  5 | ASUS ROG MAXIMUS X HERO | ASUS ROG MAXIMUS X HERO, Z370,Socket 1151-V2, DDR4, ATX |
|  6 | Gigabyte H310M S2H      | Gigabyte H310M S2H, H310, Socket 1151-V2, DDR4, mATX    |
|  7 | MSI B250M GAMING PRO    | MSI B250M GAMING PRO, B250, Socket 1151, DDR4, mATX     |
|  8 | Intel Core i3-8100      | Процессор Intel.                                        |
|  9 | Intel Core i5-7400      | Процессор Intel.                                        |
| 10 | AMD FX-8320E            | Процессор AMD.                                          |
| 11 | AMD FX-8320             | Процессор AMD.                                          |
| 12 | ASUS ROG MAXIMUS X HERO | ASUS ROG MAXIMUS X HERO, Z370,Socket 1151-V2, DDR4, ATX |
| 13 | Gigabyte H310M S2H      | Gigabyte H310M S2H, H310, Socket 1151-V2, DDR4, mATX    |
| 14 | MSI B250M GAMING PRO    | MSI B250M GAMING PRO, B250, Socket 1151, DDR4, mATX     |
+----+-------------------------+---------------------------------------------------------+

-- существуют множество способов избавиться от дубликатов. (пока не знакомы с JSON соединениями, и многотабличным запросом DELETE), решим задачу через промежуточную таблицу:

-- Запрос на извлечение записей которые пойдут в эту таблицу:
SELECT 
	name, CONCAT(SUBSTRING(description, 1, 14), ' ...') AS description , price, catalog_id
FROM 
	products
GROUP BY
	name, description, price, catalog_id;
+-------------------------+--------------------+----------+------------+
| name                    | description        | price    | catalog_id |
+-------------------------+--------------------+----------+------------+
| AMD FX-8320             | Процессор AMD. ... |  7120.00 |          1 |
| AMD FX-8320E            | Процессор AMD. ... |  4780.00 |          1 |
| ASUS ROG MAXIMUS X HERO | ASUS ROG MAXIM ... | 19310.00 |          2 |
| Gigabyte H310M S2H      | Gigabyte H310M ... |  4790.00 |          2 |
| Intel Core i3-8100      | Процессор Inte ... |  7890.00 |          1 |
| Intel Core i5-7400      | Процессор Inte ... | 12700.00 |          1 |
| MSI B250M GAMING PRO    | MSI B250M GAMI ... |  5060.00 |          2 |
+-------------------------+--------------------+----------+------------+
-- вместо 14 записей остаются 7 уникальных
-- GROUP BY может принимать несколько столбцов. Чтобы запись попала в группу, все поля должны совпадать.

--Создадим новую таблицу products_new, точно такую, как products
+------------+---------------------+------+-----+-------------------+-----------------+
| Field      | Type                | Null | Key | Default           | Extra           |
+------------+---------------------+------+-----+-------------------+-----------------+
| id         | bigint(20) unsigned | NO   | PRI | NULL              | auto_inc...     |
| name       | varchar(255)        | YES  |     | NULL              |                 |
| desription | text                | YES  |     | NULL              |                 |
| price      | decimal(11,2)       | YES  |     | NULL              |                 |
| catalog_id | int(10) unsigned    | YES  | MUL | NULL              |                 |
| created_at | datetime            | YES  |     | CURRENT_TIMESTAMP |                 |
| updated_at | datetime            | YES  |     | CURRENT_TIMESTAMP |on update CURR.. |
+------------+---------------------+------+-----+-------------------+-----------------+

-- составим запрос который будет вставлят в новую таблицу только уникальные данные
INSERT INTO
	products_new
SELECT 
	NULL, name, description , price, catalog_id, NOW(), NOW()
FROM     -- поля id, created_at, updated_at не входят в групповой запрос. Заменили.
	products
GROUP BY
	name, description, price, catalog_id;
	
-- получилась промежуточная таблица:	
SELECT 
	name, CONCAT(SUBSTRING(description, 1, 14), ' ...') AS description , price, catalog_id
FROM 
	products_new;
+-------------------------+--------------------+----------+------------+
| name                    | description        | price    | catalog_id |
+-------------------------+--------------------+----------+------------+
| AMD FX-8320             | Процессор AMD. ... |  7120.00 |          1 |
| AMD FX-8320E            | Процессор AMD. ... |  4780.00 |          1 |
| ASUS ROG MAXIMUS X HERO | ASUS ROG MAXIM ... | 19310.00 |          2 |
| Gigabyte H310M S2H      | Gigabyte H310M ... |  4790.00 |          2 |
| Intel Core i3-8100      | Процессор Inte ... |  7890.00 |          1 |
| Intel Core i5-7400      | Процессор Inte ... | 12700.00 |          1 |
| MSI B250M GAMING PRO    | MSI B250M GAMI ... |  5060.00 |          2 |
+-------------------------+--------------------+----------+------------+

-- теперь можно уничтожить первую таблицу:
DROP TABLE products;
-- и переименуем products_new в products:
ALTER TABLE products_new RENAME products;
-- посмотрим содержимое базы данных:
+----------------------+
| Tables_in_geekbrains |
+----------------------+
| catalogs             |
| discounts            |
| distances            |
| orders               |
| orders_products      |
| products             |
| rainbow              |
| storehouses          |
| storehouses_products |
| tbl                  |
| triangles            |
| users                |
+----------------------+

-- и посомтрим содержимое таблицы products:
SELECT 
	name, CONCAT(SUBSTRING(description, 1, 14), ' ...') AS description , price, catalog_id
FROM 
	products;
+-------------------------+--------------------+----------+------------+
| name                    | description        | price    | catalog_id |
+-------------------------+--------------------+----------+------------+
| AMD FX-8320             | Процессор AMD. ... |  7120.00 |          1 |
| AMD FX-8320E            | Процессор AMD. ... |  4780.00 |          1 |
| ASUS ROG MAXIMUS X HERO | ASUS ROG MAXIM ... | 19310.00 |          2 |
| Gigabyte H310M S2H      | Gigabyte H310M ... |  4790.00 |          2 |
| Intel Core i3-8100      | Процессор Inte ... |  7890.00 |          1 |
| Intel Core i5-7400      | Процессор Inte ... | 12700.00 |          1 |
| MSI B250M GAMING PRO    | MSI B250M GAMI ... |  5060.00 |          2 |
+-------------------------+--------------------+----------+------------+	
-- мы избавились от дублирующих записей


-- Для группировки можно использовать вычисляемые значения 

--Добавим несколько пользователей
INSERTinto users (name, birthday_at) VALUES 
	('Светлана','1988-02-04'),
	('Олег','1998-03-20'),
	('Юлия','2006-07-12');
	
SELECT name, birthday_at FROM users order by birthday_at;
+-----------+-------------+
| name      | birthday_at |
+-----------+-------------+
| Наталья   | 1984-11-12  |
| Александр | 1985-05-20  |
| Светлана  | 1988-02-04  | -- Родились в 1988 году
| Сергей    | 1988-02-14  | -- Родились в 1988 году
| Геннадий  | 1990-10-05  |
| Иван      | 1998-01-12  | -- Родились в 1998 году
| Олег      | 1998-03-20  | -- Родились в 1998 году
| Юлия      | 2006-07-12  | --
| Мария     | 2006-08-29  | --
+-----------+-------------+

SELECT YEAR(birthday_at) FROM users order by birthday_at;
+-------------------+
| YEAR(birthday_at) | --вывели только года рождения
+-------------------+
|              1984 |
|              1985 |
|              1988 |
|              1988 |
|              1990 |
|              1998 |
|              1998 |
|              2006 |
|              2006 |
+-------------------+

SELECT 
	MAX(name), -- необходимо агрегационное значение, чтобы не получить ошибку
	YEAR(birthday_at) AS birthday_year
FROM users 
GROUP BY birthday_year
order by birthday_year;
+-----------+---------------+
| MAX(name) | birthday_year |
+-----------+---------------+
| Наталья   |          1984 |
| Александр |          1985 |
| Сергей    |          1988 |
| Геннадий  |          1990 |
| Олег      |          1998 |
| Юлия      |          2006 |
+-----------+---------------+

SELECT 
	ANY_VALUE(name), -- лучше применить так. Случайное значение из группы
	YEAR(birthday_at) AS birthday_year
FROM users 
GROUP BY birthday_year
order by birthday_year;
+-----------------+---------------+
| ANY_VALUE(name) | birthday_year |
+-----------------+---------------+
| Наталья         |          1984 |
| Александр       |          1985 |
| Сергей          |          1988 |
| Геннадий        |          1990 |
| Иван            |          1998 |
| Мария           |          2006 |
+-----------------+---------------+


-- Подсчитаем количество пользователей по десятилетиям:
SELECT 
	SUBSTRING(birthday_at, 1, 3) AS decade, 
	COUNT(*)
FROM users 
GROUP BY decade;
+--------+----------+
| decade | COUNT(*) |
+--------+----------+
| 198    |        4 |
| 199    |        3 |
| 200    |        2 |
+--------+----------+

--с помошью #WITH ROOLUP получим результирующую строку:
SELECT 
	SUBSTRING(birthday_at, 1, 3) AS decade, 
	COUNT(*)
FROM users 
GROUP BY decade
WITH ROLLUP;
+--------+----------+
| decade | COUNT(*) |
+--------+----------+
| 198    |        4 |
| 199    |        3 |
| 200    |        2 |
| NULL   |        9 |
+--------+----------+
--Добавление модификатора WITH ROLLUP в предложение GROUP BY приводит к тому, что запрос создает еще одну (суперагрегированную) строку, которая показывает общий итог по всем значениям.

--В MySQL есть GROUPING... нужно почитать. Можно заменить значение NULL (Например: Итог). Если до него есть значения в столбце, то принимает значение 0. Применяя конструкцию IF можно вывести необходимые данные.










_________________________________________________________________________________________
_________________________________________________________________________________________
_________________________________________________________________________________________
_________________________________________________________________________________________
 
 
